<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BaiterFPS</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0a0f; color: #fff; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
    canvas { display: block; }

    #menu {
      position: fixed; inset: 0;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      background: radial-gradient(ellipse at center, #0d1b2a 0%, #050508 100%);
      z-index: 10;
    }
    #menu h1 {
      font-size: 4rem; font-weight: 900; letter-spacing: 0.1em;
      color: #e63946; text-shadow: 0 0 30px #e63946aa;
      margin-bottom: 3rem;
    }
    .menu-btn {
      width: 280px; padding: 1rem 2rem;
      margin: 0.6rem 0;
      background: transparent;
      border: 2px solid #e63946;
      color: #fff; font-size: 1.2rem;
      cursor: pointer; letter-spacing: 0.05em;
      transition: background 0.2s, box-shadow 0.2s;
    }
    .menu-btn:hover {
      background: #e63946;
      box-shadow: 0 0 20px #e63946;
    }

    #code-dialog {
      position: fixed; inset: 0;
      display: none; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.85); z-index: 20;
    }
    #code-dialog.visible { display: flex; }
    .dialog-box {
      background: #0d1b2a; border: 2px solid #e63946;
      padding: 2.5rem 3rem; display: flex; flex-direction: column; gap: 1rem;
      min-width: 320px;
    }
    .dialog-box h2 { color: #e63946; font-size: 1.5rem; }
    .dialog-box input {
      background: #111; border: 1px solid #444; color: #fff;
      padding: 0.7rem 1rem; font-size: 1.3rem; letter-spacing: 0.15em;
      text-transform: uppercase; outline: none;
    }
    .dialog-box input:focus { border-color: #e63946; }
    .dialog-row { display: flex; gap: 0.5rem; }
    .dialog-row button {
      flex: 1; padding: 0.7rem;
      background: transparent; border: 1.5px solid #e63946;
      color: #fff; cursor: pointer; font-size: 1rem;
      transition: background 0.15s;
    }
    .dialog-row button:hover { background: #e63946; }
    #dialog-error { color: #ff6b6b; font-size: 0.9rem; min-height: 1.2rem; }

    #lobby-screen {
      position: fixed; inset: 0;
      display: none; flex-direction: column;
      align-items: center; justify-content: center;
      background: radial-gradient(ellipse at center, #0d1b2a 0%, #050508 100%);
      z-index: 10;
    }
    #lobby-screen.visible { display: flex; }
    #lobby-screen h2 { font-size: 2rem; color: #e63946; margin-bottom: 1rem; }
    #lobby-code-display {
      font-size: 3rem; font-weight: 900; letter-spacing: 0.3em;
      color: #fff; background: #111; padding: 0.8rem 2rem;
      border: 2px solid #e63946; margin-bottom: 0.5rem;
    }
    #lobby-map-display { color: #aaa; font-size: 1.1rem; margin-bottom: 2rem; }
    #player-count { color: #aaa; font-size: 1rem; margin-bottom: 2rem; }
    #start-btn {
      width: 220px; padding: 1rem;
      background: #e63946; border: none;
      color: #fff; font-size: 1.2rem; cursor: pointer;
      transition: box-shadow 0.2s;
    }
    #start-btn:hover { box-shadow: 0 0 20px #e63946; }

    #loading-screen {
      position: fixed; inset: 0;
      display: none; flex-direction: column;
      align-items: center; justify-content: center;
      background: #050508; z-index: 30;
    }
    #loading-screen.visible { display: flex; }
    #loading-screen p { font-size: 1.4rem; color: #e63946; margin-bottom: 1rem; }
    #loading-bar-wrap {
      width: 320px; height: 6px;
      background: #222; border-radius: 3px; overflow: hidden;
    }
    #loading-bar {
      height: 100%; width: 0%;
      background: #e63946; transition: width 0.2s;
    }

    #hud {
      position: fixed; top: 0; left: 0; right: 0;
      display: none; align-items: center; justify-content: space-between;
      padding: 0.8rem 1.5rem;
      background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent);
      z-index: 5; pointer-events: none;
    }
    #hud.visible { display: flex; }
    #hud-code { color: #e63946; font-weight: bold; letter-spacing: 0.1em; }
    #hud-map { color: #aaa; }
    #hud-players { color: #fff; }

    #crosshair {
      position: fixed; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      display: none; pointer-events: none; z-index: 5;
      width: 0; height: 0;
    }
    #crosshair.visible { display: block; }
    #crosshair::before, #crosshair::after {
      content: ''; position: absolute;
      background: rgba(255,255,255,0.85);
    }
    #crosshair::before { width: 2px; height: 16px; top: -8px; left: -1px; }
    #crosshair::after  { width: 16px; height: 2px; top: -1px; left: -8px; }

    #lock-msg {
      position: fixed; bottom: 3rem; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.7); padding: 0.6rem 1.4rem;
      color: #aaa; font-size: 0.95rem;
      display: none; z-index: 5;
    }
    #lock-msg.visible { display: block; }
  </style>
</head>
<body>

<!-- Main Menu -->
<div id="menu">
  <h1>BAITERFPS</h1>
  <button class="menu-btn" id="btn-create">CREATE LOBBY</button>
  <button class="menu-btn" id="btn-enter">ENTER CODE</button>
</div>

<!-- Enter Code Dialog -->
<div id="code-dialog">
  <div class="dialog-box">
    <h2>ENTER LOBBY CODE</h2>
    <input id="code-input" type="text" maxlength="6" placeholder="XXXXXX" autocomplete="off" />
    <div id="dialog-error"></div>
    <div class="dialog-row">
      <button id="code-join-btn">JOIN</button>
      <button id="code-cancel-btn">CANCEL</button>
    </div>
  </div>
</div>

<!-- Lobby Waiting Screen -->
<div id="lobby-screen">
  <h2>LOBBY</h2>
  <div id="lobby-code-display">------</div>
  <div id="lobby-map-display">Map: -</div>
  <div id="player-count">Players: 1 / 16</div>
  <button id="start-btn">START GAME</button>
</div>

<!-- Loading Screen -->
<div id="loading-screen">
  <p id="loading-text">Loading map...</p>
  <div id="loading-bar-wrap"><div id="loading-bar"></div></div>
</div>

<!-- HUD -->
<div id="hud">
  <div id="hud-code"></div>
  <div id="hud-map"></div>
  <div id="hud-players"></div>
</div>
<div id="crosshair"></div>
<div id="lock-msg">Click to capture mouse</div>

<!-- Three.js + Socket.io -->
<script src="/socket.io/socket.io.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "/vendor/three/build/three.module.js",
    "three/addons/": "/vendor/three/examples/jsm/"
  }
}
</script>
<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

// Service Worker for asset caching
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js').catch(() => {});
}

// DOM refs
const menuEl        = document.getElementById('menu');
const btnCreate     = document.getElementById('btn-create');
const btnEnter      = document.getElementById('btn-enter');
const codeDialog    = document.getElementById('code-dialog');
const codeInput     = document.getElementById('code-input');
const codeJoinBtn   = document.getElementById('code-join-btn');
const codeCancelBtn = document.getElementById('code-cancel-btn');
const dialogError   = document.getElementById('dialog-error');
const lobbyScreen   = document.getElementById('lobby-screen');
const lobbyCodeEl   = document.getElementById('lobby-code-display');
const lobbyMapEl    = document.getElementById('lobby-map-display');
const playerCountEl = document.getElementById('player-count');
const startBtn      = document.getElementById('start-btn');
const loadingScreen = document.getElementById('loading-screen');
const loadingText   = document.getElementById('loading-text');
const loadingBar    = document.getElementById('loading-bar');
const hud           = document.getElementById('hud');
const hudCode       = document.getElementById('hud-code');
const hudMap        = document.getElementById('hud-map');
const hudPlayers    = document.getElementById('hud-players');
const crosshair     = document.getElementById('crosshair');
const lockMsg       = document.getElementById('lock-msg');

// Socket
const socket = io({ transports: ['websocket', 'polling'] });

// State
let currentMap  = null;
let currentCode = null;
let gameRunning = false;
let lobbyPlayers = 1;

// Three.js globals
let renderer, scene, camera;
let collidables = [];
let otherPlayerMeshes = {};

// Player state
const player = {
  pos: new THREE.Vector3(0, 5, 0),
  vel: new THREE.Vector3(),
  yaw: 0,
  pitch: 0,
  onGround: false,
  height: 1.8,
  radius: 0.4,
  speed: 8,
  jumpSpeed: 7,
};
const GRAVITY = -18;
const keys = {};

// Pointer lock
let isLocked = false;
document.addEventListener('pointerlockchange', () => {
  isLocked = !!renderer && document.pointerLockElement === renderer.domElement;
  if (gameRunning) lockMsg.classList.toggle('visible', !isLocked);
});
document.addEventListener('mousemove', (e) => {
  if (!isLocked) return;
  const sens = 0.0015;
  player.yaw   -= e.movementX * sens;
  player.pitch -= e.movementY * sens;
  player.pitch = Math.max(-Math.PI / 2.2, Math.min(Math.PI / 2.2, player.pitch));
});

// Keyboard
document.addEventListener('keydown', (e) => {
  keys[e.code] = true;
  if (e.code === 'Space' && player.onGround) {
    player.vel.y = player.jumpSpeed;
    player.onGround = false;
  }
});
document.addEventListener('keyup', (e) => { keys[e.code] = false; });

// ── MENU ──────────────────────────────────────────────────────────────────────
btnCreate.addEventListener('click', () => {
  socket.emit('createLobby', (res) => {
    if (!res.success) { alert('Could not create lobby.'); return; }
    currentCode  = res.code;
    currentMap   = res.map;
    lobbyPlayers = 1;
    lobbyCodeEl.textContent = res.code;
    lobbyMapEl.textContent  = 'Map: ' + formatMapName(res.map);
    playerCountEl.textContent = 'Players: 1 / 16';
    menuEl.style.display = 'none';
    lobbyScreen.classList.add('visible');
  });
});

btnEnter.addEventListener('click', () => {
  codeInput.value = '';
  dialogError.textContent = '';
  codeDialog.classList.add('visible');
  setTimeout(() => codeInput.focus(), 50);
});

codeCancelBtn.addEventListener('click', () => codeDialog.classList.remove('visible'));
codeInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') codeJoinBtn.click(); });

codeJoinBtn.addEventListener('click', () => {
  const code = codeInput.value.trim().toUpperCase();
  if (code.length !== 6) { dialogError.textContent = 'Code must be 6 characters.'; return; }
  dialogError.textContent = '';
  socket.emit('joinLobby', { code }, (res) => {
    if (!res.success) { dialogError.textContent = res.error || 'Failed to join.'; return; }
    currentCode  = code;
    currentMap   = res.map;
    lobbyPlayers = 1 + (res.existingPlayers ? res.existingPlayers.length : 0);
    lobbyCodeEl.textContent = code;
    lobbyMapEl.textContent  = 'Map: ' + formatMapName(res.map);
    playerCountEl.textContent = 'Players: ' + lobbyPlayers + ' / 16';
    if (res.existingPlayers) res.existingPlayers.forEach(remotePlayerJoined);
    codeDialog.classList.remove('visible');
    menuEl.style.display = 'none';
    lobbyScreen.classList.add('visible');
  });
});

startBtn.addEventListener('click', () => {
  lobbyScreen.classList.remove('visible');
  startGame(currentMap, currentCode);
});

function formatMapName(name) {
  return name.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
}

// ── SOCKET: multiplayer ───────────────────────────────────────────────────────
socket.on('playerJoined', (p) => {
  lobbyPlayers++;
  playerCountEl.textContent = 'Players: ' + lobbyPlayers + ' / 16';
  if (gameRunning) remotePlayerJoined(p);
});

socket.on('playerLeft', ({ id }) => {
  lobbyPlayers = Math.max(1, lobbyPlayers - 1);
  playerCountEl.textContent = 'Players: ' + lobbyPlayers + ' / 16';
  if (otherPlayerMeshes[id]) { scene.remove(otherPlayerMeshes[id]); delete otherPlayerMeshes[id]; }
});

socket.on('playerMoved', ({ id, x, y, z, yaw }) => {
  if (!gameRunning) return;
  let mesh = otherPlayerMeshes[id];
  if (!mesh) { mesh = createPlayerCube(); scene.add(mesh); otherPlayerMeshes[id] = mesh; }
  mesh.position.set(x, y, z);
  mesh.rotation.y = yaw;
});

function remotePlayerJoined(p) {
  if (!scene || otherPlayerMeshes[p.id]) return;
  const mesh = createPlayerCube();
  mesh.position.set(p.x, p.y, p.z);
  mesh.rotation.y = p.yaw || 0;
  scene.add(mesh);
  otherPlayerMeshes[p.id] = mesh;
}

function createPlayerCube() {
  const geo = new THREE.BoxGeometry(0.8, 1.8, 0.8);
  const mat = new THREE.MeshLambertMaterial({ color: 0xe63946 });
  return new THREE.Mesh(geo, mat);
}

// ── START GAME ────────────────────────────────────────────────────────────────
async function startGame(mapName, code) {
  loadingScreen.classList.add('visible');
  loadingText.textContent = 'Loading ' + formatMapName(mapName) + '...';
  loadingBar.style.width = '5%';

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);
  scene.fog = new THREE.Fog(0x87ceeb, 40, 120);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);

  // Lighting
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const sun = new THREE.DirectionalLight(0xffffff, 1.2);
  sun.position.set(50, 100, 50);
  sun.castShadow = true;
  sun.shadow.mapSize.set(2048, 2048);
  sun.shadow.camera.near = 0.5;
  sun.shadow.camera.far  = 300;
  sun.shadow.camera.left = sun.shadow.camera.bottom = -80;
  sun.shadow.camera.right = sun.shadow.camera.top   =  80;
  scene.add(sun);

  // Fallback ground
  const gGeo = new THREE.PlaneGeometry(200, 200);
  const gMat = new THREE.MeshLambertMaterial({ color: 0x3a7d44 });
  const ground = new THREE.Mesh(gGeo, gMat);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);
  collidables.push(ground);

  loadingBar.style.width = '15%';
  await loadMap(mapName);
  loadingBar.style.width = '100%';

  hudCode.textContent    = 'Code: ' + code;
  hudMap.textContent     = formatMapName(mapName);
  hudPlayers.textContent = lobbyPlayers + ' / 16';

  loadingScreen.classList.remove('visible');
  hud.classList.add('visible');
  crosshair.classList.add('visible');
  lockMsg.classList.add('visible');
  gameRunning = true;

  window.addEventListener('resize', onResize);
  renderer.domElement.addEventListener('click', () => renderer.domElement.requestPointerLock());

  animate();
}

function loadMap(mapName) {
  return new Promise((resolve) => {
    const loader = new GLTFLoader();
    loader.load(
      '/maps/' + mapName + '/scene.gltf',
      (gltf) => {
        const root = gltf.scene;

        // Compute initial bounding box (respects GLTF root matrix / rotations)
        const initBox = new THREE.Box3().setFromObject(root);
        const initSize = initBox.getSize(new THREE.Vector3());
        const maxDim = Math.max(initSize.x, initSize.y, initSize.z);

        // Auto-scale so the longest dimension becomes ~150 world units
        const targetSize = 150;
        const scaleFactor = maxDim > 0 ? targetSize / maxDim : 1;
        root.scale.setScalar(scaleFactor);

        // Recompute bounding box after scaling
        const box = new THREE.Box3().setFromObject(root);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());

        // Center horizontally and place bottom of map at y=0
        root.position.set(-center.x, -box.min.y, -center.z);

        root.traverse((node) => {
          if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
            collidables.push(node);
          }
        });
        scene.add(root);

        // Spawn player just above the map centre at street level
        player.pos.set(0, size.y * 0.1 + player.height + 1, 0);
        resolve();
      },
      (xhr) => {
        if (xhr.total > 0) {
          loadingBar.style.width = (15 + (xhr.loaded / xhr.total) * 80) + '%';
        }
      },
      (err) => { console.error('Map load error', err); resolve(); }
    );
  });
}

// ── PHYSICS ───────────────────────────────────────────────────────────────────
const downRay = new THREE.Raycaster();
const wallRay = new THREE.Raycaster();
const downDir = new THREE.Vector3(0, -1, 0);
const wallDirs = [
  new THREE.Vector3( 1, 0,  0),
  new THREE.Vector3(-1, 0,  0),
  new THREE.Vector3( 0, 0,  1),
  new THREE.Vector3( 0, 0, -1),
];

function updatePhysics(dt) {
  if (!player.onGround) player.vel.y += GRAVITY * dt;

  // Horizontal movement
  const move = new THREE.Vector3();
  if (keys['KeyW']) move.z -= 1;
  if (keys['KeyS']) move.z += 1;
  if (keys['KeyA']) move.x -= 1;
  if (keys['KeyD']) move.x += 1;
  if (move.lengthSq() > 0) {
    move.normalize().applyEuler(new THREE.Euler(0, player.yaw, 0));
    player.vel.x = move.x * player.speed;
    player.vel.z = move.z * player.speed;
  } else {
    player.vel.x *= 0.82;
    player.vel.z *= 0.82;
  }

  const next = player.pos.clone().addScaledVector(player.vel, dt);

  // Ground collision
  downRay.set(new THREE.Vector3(next.x, player.pos.y + 0.3, next.z), downDir);
  downRay.far = player.height + 0.5;
  const groundHits = downRay.intersectObjects(collidables, true);
  if (groundHits.length > 0 && groundHits[0].distance <= player.height + 0.2) {
    next.y = groundHits[0].point.y + player.height;
    player.vel.y = 0;
    player.onGround = true;
  } else {
    player.onGround = false;
  }

  // Wall collision
  const wallOrigin = new THREE.Vector3(next.x, next.y - player.height * 0.5, next.z);
  for (const dir of wallDirs) {
    wallRay.set(wallOrigin, dir);
    wallRay.far = player.radius + 0.05;
    const hits = wallRay.intersectObjects(collidables, true);
    if (hits.length > 0) {
      const overlap = (player.radius + 0.05) - hits[0].distance;
      next.x -= dir.x * overlap;
      next.z -= dir.z * overlap;
    }
  }

  // Floor safety net
  if (next.y < player.height) { next.y = player.height; player.vel.y = 0; player.onGround = true; }

  player.pos.copy(next);
}

// ── RENDER LOOP ───────────────────────────────────────────────────────────────
let prevTime = 0;
let lastSend = 0;

function animate(ts = 0) {
  requestAnimationFrame(animate);
  if (!gameRunning) return;

  const dt = Math.min((ts - prevTime) / 1000, 0.05);
  prevTime = ts;

  updatePhysics(dt);

  camera.position.copy(player.pos);
  camera.rotation.order = 'YXZ';
  camera.rotation.y = player.yaw;
  camera.rotation.x = player.pitch;

  // Network update ~20 Hz
  if (ts - lastSend > 50) {
    socket.emit('playerMove', { x: player.pos.x, y: player.pos.y, z: player.pos.z, yaw: player.yaw });
    lastSend = ts;
    hudPlayers.textContent = (1 + Object.keys(otherPlayerMeshes).length) + ' / 16';
  }

  renderer.render(scene, camera);
}

function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
</script>
</body>
</html>
