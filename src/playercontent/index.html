<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BaiterFPS</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0a0f; color: #fff; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
    canvas { display: block; }

    #menu {
      position: fixed; inset: 0;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      background: radial-gradient(ellipse at center, #0d1b2a 0%, #050508 100%);
      z-index: 10;
    }
    #menu h1 {
      font-size: 4rem; font-weight: 900; letter-spacing: 0.1em;
      color: #e63946; text-shadow: 0 0 30px #e63946aa;
      margin-bottom: 1.5rem;
    }
    #name-row {
      display: flex; align-items: center; gap: 0.5rem;
      margin-bottom: 2rem;
    }
    #name-row label { color: #aaa; font-size: 1rem; }
    #name-input {
      background: #111; border: 1px solid #444; color: #fff;
      padding: 0.5rem 0.8rem; font-size: 1rem; outline: none;
      width: 180px;
    }
    #name-input:focus { border-color: #e63946; }
    #name-save {
      padding: 0.5rem 1rem; background: transparent;
      border: 1.5px solid #e63946; color: #fff;
      cursor: pointer; font-size: 0.9rem;
      transition: background 0.15s;
    }
    #name-save:hover { background: #e63946; }
    .menu-btn {
      width: 280px; padding: 1rem 2rem;
      margin: 0.6rem 0;
      background: transparent;
      border: 2px solid #e63946;
      color: #fff; font-size: 1.2rem;
      cursor: pointer; letter-spacing: 0.05em;
      transition: background 0.2s, box-shadow 0.2s;
    }
    .menu-btn:hover {
      background: #e63946;
      box-shadow: 0 0 20px #e63946;
    }
    .menu-btn.quick-play {
      border-color: #4caf50; color: #4caf50;
    }
    .menu-btn.quick-play:hover {
      background: #4caf50; color: #fff;
      box-shadow: 0 0 20px #4caf50;
    }

    #create-dialog {
      position: fixed; inset: 0;
      display: none; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.85); z-index: 20;
    }
    #create-dialog.visible { display: flex; }

    #code-dialog {
      position: fixed; inset: 0;
      display: none; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.85); z-index: 20;
    }
    #code-dialog.visible { display: flex; }
    .dialog-box {
      background: #0d1b2a; border: 2px solid #e63946;
      padding: 2.5rem 3rem; display: flex; flex-direction: column; gap: 1rem;
      min-width: 320px;
    }
    .dialog-box h2 { color: #e63946; font-size: 1.5rem; }
    .dialog-box input {
      background: #111; border: 1px solid #444; color: #fff;
      padding: 0.7rem 1rem; font-size: 1.3rem; letter-spacing: 0.15em;
      text-transform: uppercase; outline: none;
    }
    .dialog-box input:focus { border-color: #e63946; }
    .dialog-box label { color: #aaa; font-size: 1rem; margin-bottom: 0.2rem; }
    .dialog-box select {
      background: #111; border: 1px solid #444; color: #fff;
      padding: 0.7rem 1rem; font-size: 1.1rem; outline: none;
      cursor: pointer;
    }
    .dialog-box select:focus { border-color: #e63946; }
    .dialog-row { display: flex; gap: 0.5rem; }
    .dialog-row button {
      flex: 1; padding: 0.7rem;
      background: transparent; border: 1.5px solid #e63946;
      color: #fff; cursor: pointer; font-size: 1rem;
      transition: background 0.15s;
    }
    .dialog-row button:hover { background: #e63946; }
    #dialog-error { color: #ff6b6b; font-size: 0.9rem; min-height: 1.2rem; }

    #lobby-screen {
      position: fixed; inset: 0;
      display: none; flex-direction: column;
      align-items: center; justify-content: flex-start;
      padding-top: 2rem;
      background: radial-gradient(ellipse at center, #0d1b2a 0%, #050508 100%);
      z-index: 10; overflow-y: auto;
    }
    #lobby-screen.visible { display: flex; }
    #lobby-screen h2 { font-size: 2rem; color: #e63946; margin-bottom: 0.5rem; }
    #lobby-code-display {
      font-size: 2.5rem; font-weight: 900; letter-spacing: 0.3em;
      color: #fff; background: #111; padding: 0.5rem 1.5rem;
      border: 2px solid #e63946; margin-bottom: 0.5rem;
    }
    #lobby-map-display { color: #aaa; font-size: 1.1rem; margin-bottom: 0.3rem; }
    #map-select-row {
      display: none; align-items: center; gap: 0.5rem;
      margin-bottom: 0.5rem;
    }
    #map-select-row.visible { display: flex; }
    #map-select-row label { color: #aaa; font-size: 1rem; }
    #lobby-map-select {
      background: #111; border: 1px solid #444; color: #fff;
      padding: 0.4rem 0.8rem; font-size: 1rem; outline: none;
      cursor: pointer;
    }
    #player-count { color: #aaa; font-size: 1rem; margin-bottom: 0.5rem; }

    #lobby-player-list {
      width: 90%; max-width: 500px;
      display: flex; flex-direction: column; gap: 0.3rem;
      margin-bottom: 0.8rem; max-height: 200px; overflow-y: auto;
    }
    .player-item {
      display: flex; justify-content: space-between; align-items: center;
      background: #111; border: 1px solid #333; padding: 0.5rem 1rem;
      font-size: 0.95rem;
    }
    .player-item .player-name { color: #fff; }
    .player-item .player-host-badge {
      color: #e63946; font-size: 0.8rem; margin-left: 0.5rem;
    }
    .player-item-actions { display: flex; gap: 0.3rem; }
    .player-item-actions button {
      padding: 0.3rem 0.6rem; font-size: 0.8rem;
      background: transparent; border: 1px solid #555;
      color: #ccc; cursor: pointer; transition: background 0.15s, border-color 0.15s;
    }
    .player-item-actions button:hover { border-color: #e63946; color: #fff; }
    .player-item-actions button.kick-btn { border-color: #e63946; color: #e63946; }
    .player-item-actions button.kick-btn:hover { background: #e63946; color: #fff; }

    #admin-controls {
      display: none; flex-direction: column; align-items: center; gap: 0.5rem;
      margin-bottom: 0.8rem;
    }
    #admin-controls.visible { display: flex; }
    #visibility-toggle {
      width: 220px; padding: 0.7rem;
      background: transparent; border: 1.5px solid #e63946;
      color: #fff; font-size: 1rem; cursor: pointer;
      transition: background 0.15s;
    }
    #visibility-toggle:hover { background: #e6394644; }
    #visibility-toggle.public { border-color: #4caf50; color: #4caf50; }
    #start-btn {
      width: 220px; padding: 1rem;
      background: #e63946; border: none;
      color: #fff; font-size: 1.2rem; cursor: pointer;
      transition: box-shadow 0.2s;
    }
    #start-btn:hover { box-shadow: 0 0 20px #e63946; }

    /* Chat (lobby + in-game) */
    #lobby-chat {
      width: 90%; max-width: 500px;
      display: flex; flex-direction: column; gap: 0.3rem;
      margin-top: 0.5rem;
    }
    #lobby-chat-messages {
      background: #0a0a12; border: 1px solid #333;
      height: 140px; overflow-y: auto; padding: 0.5rem;
      font-size: 0.85rem; color: #ccc;
    }
    .chat-msg { margin-bottom: 0.2rem; }
    .chat-msg.system { color: #888; font-style: italic; }
    .chat-msg.pm { color: #9b59b6; }
    .chat-msg .chat-sender { color: #e63946; font-weight: bold; }
    #lobby-chat-input-row {
      display: flex; gap: 0.3rem;
    }
    #lobby-chat-input {
      flex: 1; background: #111; border: 1px solid #444;
      color: #fff; padding: 0.5rem; font-size: 0.9rem; outline: none;
    }
    #lobby-chat-input:focus { border-color: #e63946; }
    #lobby-chat-send {
      padding: 0.5rem 1rem; background: #e63946; border: none;
      color: #fff; cursor: pointer; font-size: 0.9rem;
    }

    /* In-game chat */
    #game-chat {
      position: fixed; bottom: 1rem; left: 1rem;
      width: 350px; z-index: 6; pointer-events: none;
    }
    #game-chat.active { pointer-events: auto; }
    #game-chat-messages {
      background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.1);
      height: 120px; overflow-y: auto; padding: 0.5rem;
      font-size: 0.8rem; color: #ccc; pointer-events: auto;
    }
    #game-chat-input-row {
      display: none; gap: 0.3rem; margin-top: 0.3rem;
    }
    #game-chat-input-row.visible { display: flex; }
    #game-chat-input {
      flex: 1; background: rgba(0,0,0,0.7); border: 1px solid #555;
      color: #fff; padding: 0.4rem; font-size: 0.85rem; outline: none;
    }
    #game-chat-send {
      padding: 0.4rem 0.8rem; background: #e63946; border: none;
      color: #fff; cursor: pointer; font-size: 0.85rem;
    }

    #server-list-screen {
      position: fixed; inset: 0;
      display: none; flex-direction: column;
      align-items: center; justify-content: flex-start;
      padding-top: 4rem;
      background: radial-gradient(ellipse at center, #0d1b2a 0%, #050508 100%);
      z-index: 10; overflow-y: auto;
    }
    #server-list-screen.visible { display: flex; }
    #server-list-screen h2 { font-size: 2rem; color: #e63946; margin-bottom: 1.5rem; }
    #server-list {
      width: 90%; max-width: 600px;
      display: flex; flex-direction: column; gap: 0.5rem;
      margin-bottom: 2rem;
    }
    .server-item {
      display: flex; justify-content: space-between; align-items: center;
      background: #111; border: 1px solid #333; padding: 1rem 1.5rem;
      cursor: pointer; transition: border-color 0.15s, background 0.15s;
    }
    .server-item:hover { border-color: #e63946; background: #1a1a2e; }
    .server-item-info { display: flex; flex-direction: column; }
    .server-item-map { color: #fff; font-size: 1.1rem; }
    .server-item-status { color: #666; font-size: 0.8rem; }
    .server-item-players { color: #aaa; font-size: 0.95rem; }
    #server-list-empty { color: #666; font-size: 1rem; margin-bottom: 2rem; }
    #server-list-back {
      width: 200px; padding: 0.8rem;
      background: transparent; border: 1.5px solid #e63946;
      color: #fff; font-size: 1rem; cursor: pointer;
      transition: background 0.15s; margin-bottom: 2rem;
    }
    #server-list-back:hover { background: #e63946; }
    #server-list-refresh {
      width: 200px; padding: 0.8rem;
      background: transparent; border: 1.5px solid #4caf50;
      color: #4caf50; font-size: 1rem; cursor: pointer;
      transition: background 0.15s; margin-bottom: 1rem;
    }
    #server-list-refresh:hover { background: #4caf5044; }

    #loading-screen {
      position: fixed; inset: 0;
      display: none; flex-direction: column;
      align-items: center; justify-content: center;
      background: #050508; z-index: 30;
    }
    #loading-screen.visible { display: flex; }
    #loading-screen p { font-size: 1.4rem; color: #e63946; margin-bottom: 1rem; }
    #loading-bar-wrap {
      width: 320px; height: 6px;
      background: #222; border-radius: 3px; overflow: hidden;
    }
    #loading-bar {
      height: 100%; width: 0%;
      background: #e63946; transition: width 0.2s;
    }

    #hud {
      position: fixed; top: 0; left: 0; right: 0;
      display: none; align-items: center; justify-content: space-between;
      padding: 0.8rem 1.5rem;
      background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent);
      z-index: 5; pointer-events: none;
    }
    #hud.visible { display: flex; }
    #hud-code { color: #e63946; font-weight: bold; letter-spacing: 0.1em; }
    #hud-map { color: #aaa; }
    #hud-players { color: #fff; }

    #crosshair {
      position: fixed; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      display: none; pointer-events: none; z-index: 5;
      width: 0; height: 0;
    }
    #crosshair.visible { display: block; }
    #crosshair::before, #crosshair::after {
      content: ''; position: absolute;
      background: rgba(255,255,255,0.85);
    }
    #crosshair::before { width: 2px; height: 16px; top: -8px; left: -1px; }
    #crosshair::after  { width: 16px; height: 2px; top: -1px; left: -8px; }

    #lock-msg {
      position: fixed; bottom: 3rem; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.7); padding: 0.6rem 1.4rem;
      color: #aaa; font-size: 0.95rem;
      display: none; z-index: 5;
    }
    #lock-msg.visible { display: block; }

    /* Kicked overlay */
    #kicked-overlay {
      position: fixed; inset: 0;
      display: none; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.9); z-index: 25;
    }
    #kicked-overlay.visible { display: flex; }
    #kicked-overlay .dialog-box { text-align: center; }
    #kicked-overlay p { color: #ff6b6b; font-size: 1.2rem; margin-bottom: 1rem; }
  </style>
</head>
<body>

<!-- Main Menu -->
<div id="menu">
  <h1>BAITERFPS</h1>
  <div id="name-row">
    <label>Name:</label>
    <input id="name-input" type="text" maxlength="20" placeholder="Loading..." autocomplete="off" />
    <button id="name-save">SAVE</button>
  </div>
  <button class="menu-btn" id="btn-create">CREATE LOBBY</button>
  <button class="menu-btn" id="btn-enter">ENTER CODE</button>
  <button class="menu-btn" id="btn-servers">SERVER LIST</button>
  <button class="menu-btn quick-play" id="btn-quickplay">⚡ QUICK PLAY</button>
</div>

<!-- Create Lobby Dialog (map selection) -->
<div id="create-dialog">
  <div class="dialog-box">
    <h2>CREATE LOBBY</h2>
    <label>Select Map</label>
    <select id="create-map-select">
      <option value="arabic_city">Arab City</option>
      <option value="snow_town">Snowy Village</option>
    </select>
    <div class="dialog-row">
      <button id="create-confirm-btn">CREATE</button>
      <button id="create-cancel-btn">CANCEL</button>
    </div>
  </div>
</div>

<!-- Enter Code Dialog -->
<div id="code-dialog">
  <div class="dialog-box">
    <h2>ENTER LOBBY CODE</h2>
    <input id="code-input" type="text" maxlength="6" placeholder="XXXXXX" autocomplete="off" />
    <div id="dialog-error"></div>
    <div class="dialog-row">
      <button id="code-join-btn">JOIN</button>
      <button id="code-cancel-btn">CANCEL</button>
    </div>
  </div>
</div>

<!-- Server List Screen -->
<div id="server-list-screen">
  <h2>PUBLIC SERVERS</h2>
  <button id="server-list-refresh">REFRESH</button>
  <div id="server-list"></div>
  <div id="server-list-empty">No public servers available.</div>
  <button id="server-list-back">BACK</button>
</div>

<!-- Lobby Waiting Screen -->
<div id="lobby-screen">
  <h2>LOBBY</h2>
  <div id="lobby-code-display">------</div>
  <div id="lobby-map-display">Map: -</div>
  <div id="map-select-row">
    <label>Change Map:</label>
    <select id="lobby-map-select">
      <option value="arabic_city">Arab City</option>
      <option value="snow_town">Snowy Village</option>
    </select>
  </div>
  <div id="player-count">Players: 1 / 16</div>
  <div id="lobby-player-list"></div>
  <div id="admin-controls">
    <button id="visibility-toggle">PRIVATE</button>
    <button id="start-btn">START GAME</button>
  </div>
  <div id="lobby-chat">
    <div id="lobby-chat-messages"></div>
    <div id="lobby-chat-input-row">
      <input id="lobby-chat-input" type="text" maxlength="200" placeholder="Type a message..." autocomplete="off" />
      <button id="lobby-chat-send">SEND</button>
    </div>
  </div>
</div>

<!-- Loading Screen -->
<div id="loading-screen">
  <p id="loading-text">Loading map...</p>
  <div id="loading-bar-wrap"><div id="loading-bar"></div></div>
</div>

<!-- Kicked Overlay -->
<div id="kicked-overlay">
  <div class="dialog-box">
    <h2>KICKED</h2>
    <p id="kicked-reason">You were kicked from the lobby.</p>
    <div class="dialog-row">
      <button id="kicked-ok-btn">OK</button>
    </div>
  </div>
</div>

<!-- HUD -->
<div id="hud">
  <div id="hud-code"></div>
  <div id="hud-map"></div>
  <div id="hud-players"></div>
</div>
<div id="crosshair"></div>
<div id="lock-msg">Click to capture mouse</div>

<!-- In-game chat -->
<div id="game-chat">
  <div id="game-chat-messages"></div>
  <div id="game-chat-input-row">
    <input id="game-chat-input" type="text" maxlength="200" placeholder="Press T to chat..." autocomplete="off" />
    <button id="game-chat-send">SEND</button>
  </div>
</div>

<!-- Three.js + Socket.io -->
<script src="/socket.io/socket.io.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "/vendor/three/build/three.module.js",
    "three/addons/": "/vendor/three/examples/jsm/"
  }
}
</script>
<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

// Service Worker for asset caching
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js').catch(() => {});
}

// DOM refs
const menuEl          = document.getElementById('menu');
const nameInput       = document.getElementById('name-input');
const nameSaveBtn     = document.getElementById('name-save');
const btnCreate       = document.getElementById('btn-create');
const btnEnter        = document.getElementById('btn-enter');
const btnServers      = document.getElementById('btn-servers');
const btnQuickPlay    = document.getElementById('btn-quickplay');
const createDialog    = document.getElementById('create-dialog');
const createMapSelect = document.getElementById('create-map-select');
const createConfirmBtn= document.getElementById('create-confirm-btn');
const createCancelBtn = document.getElementById('create-cancel-btn');
const codeDialog      = document.getElementById('code-dialog');
const codeInput       = document.getElementById('code-input');
const codeJoinBtn     = document.getElementById('code-join-btn');
const codeCancelBtn   = document.getElementById('code-cancel-btn');
const dialogError     = document.getElementById('dialog-error');
const lobbyScreen     = document.getElementById('lobby-screen');
const lobbyCodeEl     = document.getElementById('lobby-code-display');
const lobbyMapEl      = document.getElementById('lobby-map-display');
const mapSelectRow    = document.getElementById('map-select-row');
const lobbyMapSelect  = document.getElementById('lobby-map-select');
const playerCountEl   = document.getElementById('player-count');
const lobbyPlayerList = document.getElementById('lobby-player-list');
const adminControls   = document.getElementById('admin-controls');
const visibilityBtn   = document.getElementById('visibility-toggle');
const startBtn        = document.getElementById('start-btn');
const lobbyChatMsgs   = document.getElementById('lobby-chat-messages');
const lobbyChatInput  = document.getElementById('lobby-chat-input');
const lobbyChatSend   = document.getElementById('lobby-chat-send');
const serverListScreen  = document.getElementById('server-list-screen');
const serverListEl      = document.getElementById('server-list');
const serverListEmpty   = document.getElementById('server-list-empty');
const serverListBack    = document.getElementById('server-list-back');
const serverListRefresh = document.getElementById('server-list-refresh');
const loadingScreen   = document.getElementById('loading-screen');
const loadingText     = document.getElementById('loading-text');
const loadingBar      = document.getElementById('loading-bar');
const hud             = document.getElementById('hud');
const hudCode         = document.getElementById('hud-code');
const hudMap          = document.getElementById('hud-map');
const hudPlayers      = document.getElementById('hud-players');
const crosshair       = document.getElementById('crosshair');
const lockMsg         = document.getElementById('lock-msg');
const kickedOverlay   = document.getElementById('kicked-overlay');
const kickedReason    = document.getElementById('kicked-reason');
const kickedOkBtn     = document.getElementById('kicked-ok-btn');
const gameChatEl      = document.getElementById('game-chat');
const gameChatMsgs    = document.getElementById('game-chat-messages');
const gameChatInputRow= document.getElementById('game-chat-input-row');
const gameChatInput   = document.getElementById('game-chat-input');
const gameChatSend    = document.getElementById('game-chat-send');

// Socket — prefer websocket for speed
const socket = io({ transports: ['websocket', 'polling'] });

// State
let currentMap  = null;
let currentCode = null;
let gameRunning = false;
let lobbyPlayers = 1;
let lobbyIsPublic = false;
let isHost = false;
let myName = '';
let chatOpen = false;

// Three.js globals
let renderer, scene, camera;
let collidables = [];
let otherPlayerMeshes = {};

// Player state
const player = {
  pos: new THREE.Vector3(0, 5, 0),
  vel: new THREE.Vector3(),
  yaw: 0,
  pitch: 0,
  onGround: false,
  height: 1.8,
  radius: 0.4,
  speed: 8,
  jumpSpeed: 7,
};
const GRAVITY = -18;
const keys = {};

// ── Name assignment ───────────────────────────────────────────────────────────
socket.on('assignedName', ({ name }) => {
  myName = name;
  nameInput.value = name;
});

nameSaveBtn.addEventListener('click', () => {
  const newName = nameInput.value.trim().substring(0, 20);
  if (!newName) return;
  socket.emit('setName', { name: newName }, (res) => {
    if (res && res.success) {
      myName = res.name;
      nameInput.value = res.name;
    }
  });
});

// Pointer lock
let isLocked = false;
document.addEventListener('pointerlockchange', () => {
  isLocked = !!renderer && document.pointerLockElement === renderer.domElement;
  if (gameRunning) lockMsg.classList.toggle('visible', !isLocked);
});
document.addEventListener('mousemove', (e) => {
  if (!isLocked) return;
  const sens = 0.0015;
  player.yaw   -= e.movementX * sens;
  player.pitch -= e.movementY * sens;
  player.pitch = Math.max(-Math.PI / 2.2, Math.min(Math.PI / 2.2, player.pitch));
});

// Keyboard
document.addEventListener('keydown', (e) => {
  // Don't capture game keys when chat is open
  if (chatOpen && e.code !== 'Escape') return;

  keys[e.code] = true;
  if (e.code === 'Space' && player.onGround) {
    player.vel.y = player.jumpSpeed;
    player.onGround = false;
  }
  // Open in-game chat with T
  if (e.code === 'KeyT' && gameRunning && !chatOpen) {
    e.preventDefault();
    openGameChat();
  }
});
document.addEventListener('keyup', (e) => {
  if (chatOpen && e.code === 'Escape') {
    closeGameChat();
    return;
  }
  keys[e.code] = false;
});

function openGameChat() {
  chatOpen = true;
  gameChatInputRow.classList.add('visible');
  gameChatEl.classList.add('active');
  gameChatInput.focus();
  if (document.pointerLockElement) document.exitPointerLock();
}

function closeGameChat() {
  chatOpen = false;
  gameChatInputRow.classList.remove('visible');
  gameChatEl.classList.remove('active');
  gameChatInput.value = '';
}

// ── Chat helpers ──────────────────────────────────────────────────────────────
function appendChatMsg(container, { sender, text, system, pm }) {
  const div = document.createElement('div');
  div.className = 'chat-msg' + (system ? ' system' : '') + (pm ? ' pm' : '');
  if (system) {
    div.textContent = text;
  } else if (pm) {
    div.innerHTML = '<span class="chat-sender">[PM] ' + escapeHtml(sender) + ':</span> ' + escapeHtml(text);
  } else {
    div.innerHTML = '<span class="chat-sender">' + escapeHtml(sender) + ':</span> ' + escapeHtml(text);
  }
  container.appendChild(div);
  container.scrollTop = container.scrollHeight;
}

function escapeHtml(str) {
  const d = document.createElement('div');
  d.textContent = str;
  return d.innerHTML;
}

// Chat message from server
socket.on('chatMessage', (msg) => {
  if (gameRunning) {
    appendChatMsg(gameChatMsgs, msg);
  } else {
    appendChatMsg(lobbyChatMsgs, msg);
  }
});

// Lobby chat send
function sendLobbyChat() {
  const text = lobbyChatInput.value.trim();
  if (!text) return;
  socket.emit('sendChat', { text });
  lobbyChatInput.value = '';
}
lobbyChatSend.addEventListener('click', sendLobbyChat);
lobbyChatInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') sendLobbyChat(); });

// Game chat send
function sendGameChat() {
  const text = gameChatInput.value.trim();
  if (!text) return;
  socket.emit('sendChat', { text });
  closeGameChat();
}
gameChatSend.addEventListener('click', sendGameChat);
gameChatInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') sendGameChat();
  if (e.key === 'Escape') closeGameChat();
  e.stopPropagation();
});

// ── Player list in lobby ──────────────────────────────────────────────────────
socket.on('playerList', (list) => {
  renderPlayerList(list);
});

function renderPlayerList(list) {
  lobbyPlayerList.innerHTML = '';
  lobbyPlayers = list.length;
  playerCountEl.textContent = 'Players: ' + list.length + ' / 16';

  list.forEach((p) => {
    const item = document.createElement('div');
    item.className = 'player-item';

    const nameSpan = document.createElement('span');
    nameSpan.className = 'player-name';
    nameSpan.textContent = p.name;
    if (p.isHost) {
      const badge = document.createElement('span');
      badge.className = 'player-host-badge';
      badge.textContent = '★ HOST';
      nameSpan.appendChild(badge);
    }
    item.appendChild(nameSpan);

    const actions = document.createElement('span');
    actions.className = 'player-item-actions';

    // Don't show actions for yourself
    if (p.id !== socket.id) {
      if (isHost) {
        // Admin: kick button
        const kickBtn = document.createElement('button');
        kickBtn.className = 'kick-btn';
        kickBtn.textContent = 'KICK';
        kickBtn.addEventListener('click', () => {
          socket.emit('kickPlayer', { targetId: p.id }, (res) => {
            if (res && !res.success) alert(res.error || 'Failed to kick');
          });
        });
        actions.appendChild(kickBtn);
      }
      // Report button
      const reportBtn = document.createElement('button');
      reportBtn.textContent = 'REPORT';
      reportBtn.addEventListener('click', () => {
        socket.emit('reportPlayer', { targetId: p.id });
      });
      actions.appendChild(reportBtn);

      // PM button
      const pmBtn = document.createElement('button');
      pmBtn.textContent = 'PM';
      pmBtn.addEventListener('click', () => {
        lobbyChatInput.value = '?send:' + p.name + ';';
        lobbyChatInput.focus();
      });
      actions.appendChild(pmBtn);
    }

    item.appendChild(actions);
    lobbyPlayerList.appendChild(item);
  });
}

// ── Kicked handler ────────────────────────────────────────────────────────────
socket.on('kicked', ({ reason }) => {
  kickedReason.textContent = reason || 'You were kicked from the lobby.';
  lobbyScreen.classList.remove('visible');
  kickedOverlay.classList.add('visible');
  currentCode = null;
  currentMap = null;
  isHost = false;
});

kickedOkBtn.addEventListener('click', () => {
  kickedOverlay.classList.remove('visible');
  menuEl.style.display = '';
});

// ── MENU ──────────────────────────────────────────────────────────────────────
btnCreate.addEventListener('click', () => {
  createDialog.classList.add('visible');
});

createCancelBtn.addEventListener('click', () => {
  createDialog.classList.remove('visible');
});

createConfirmBtn.addEventListener('click', () => {
  const selectedMap = createMapSelect.value;
  createDialog.classList.remove('visible');
  socket.emit('createLobby', { map: selectedMap, isPublic: false }, (res) => {
    if (!res.success) { alert('Could not create lobby.'); return; }
    currentCode  = res.code;
    currentMap   = res.map;
    lobbyPlayers = 1;
    lobbyIsPublic = false;
    isHost = true;
    lobbyCodeEl.textContent = res.code;
    lobbyMapEl.textContent  = 'Map: ' + formatMapName(res.map);
    lobbyMapSelect.value = res.map;
    playerCountEl.textContent = 'Players: 1 / 16';
    updateVisibilityBtn();
    updateAdminUI();
    lobbyChatMsgs.innerHTML = '';
    if (res.playerList) renderPlayerList(res.playerList);
    menuEl.style.display = 'none';
    lobbyScreen.classList.add('visible');
  });
});

btnEnter.addEventListener('click', () => {
  codeInput.value = '';
  dialogError.textContent = '';
  codeDialog.classList.add('visible');
  setTimeout(() => codeInput.focus(), 50);
});

codeCancelBtn.addEventListener('click', () => codeDialog.classList.remove('visible'));
codeInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') codeJoinBtn.click(); });

codeJoinBtn.addEventListener('click', () => {
  const code = codeInput.value.trim().toUpperCase();
  if (code.length !== 6) { dialogError.textContent = 'Code must be 6 characters.'; return; }
  dialogError.textContent = '';
  joinLobbyByCode(code);
});

// Quick Play
btnQuickPlay.addEventListener('click', () => {
  socket.emit('quickPlay', (res) => {
    if (!res || !res.success) {
      alert('Could not find or create a game. Try again.');
      return;
    }
    currentCode  = res.code;
    currentMap   = res.map;
    isHost = !!res.isHost;
    lobbyIsPublic = !!res.isPublic;
    lobbyCodeEl.textContent = res.code;
    lobbyMapEl.textContent  = 'Map: ' + formatMapName(res.map);
    lobbyMapSelect.value = res.map;
    playerCountEl.textContent = 'Players: ' + (res.playerList ? res.playerList.length : 1) + ' / 16';
    updateVisibilityBtn();
    updateAdminUI();
    lobbyChatMsgs.innerHTML = '';
    if (res.playerList) renderPlayerList(res.playerList);
    if (res.existingPlayers) res.existingPlayers.forEach(remotePlayerJoined);
    menuEl.style.display = 'none';
    lobbyScreen.classList.add('visible');
  });
});

function joinLobbyByCode(code) {
  socket.emit('joinLobby', { code }, (res) => {
    if (!res.success) { dialogError.textContent = res.error || 'Failed to join.'; return; }
    currentCode  = code;
    currentMap   = res.map;
    isHost = !!res.isHost;
    lobbyPlayers = res.playerList ? res.playerList.length : (1 + (res.existingPlayers ? res.existingPlayers.length : 0));
    lobbyCodeEl.textContent = code;
    lobbyMapEl.textContent  = 'Map: ' + formatMapName(res.map);
    lobbyMapSelect.value = res.map;
    playerCountEl.textContent = 'Players: ' + lobbyPlayers + ' / 16';
    updateAdminUI();
    lobbyChatMsgs.innerHTML = '';
    if (res.playerList) renderPlayerList(res.playerList);
    if (res.existingPlayers) res.existingPlayers.forEach(remotePlayerJoined);
    codeDialog.classList.remove('visible');
    serverListScreen.classList.remove('visible');
    menuEl.style.display = 'none';
    lobbyScreen.classList.add('visible');
  });
}

function updateAdminUI() {
  if (isHost) {
    adminControls.classList.add('visible');
    mapSelectRow.classList.add('visible');
  } else {
    adminControls.classList.remove('visible');
    mapSelectRow.classList.remove('visible');
  }
}

// Map change in lobby (admin only)
lobbyMapSelect.addEventListener('change', () => {
  socket.emit('changeMap', { map: lobbyMapSelect.value }, (res) => {
    if (res && res.success) {
      currentMap = res.map;
      lobbyMapEl.textContent = 'Map: ' + formatMapName(res.map);
    }
  });
});

// Server broadcast of map change
socket.on('mapChanged', ({ map }) => {
  currentMap = map;
  lobbyMapEl.textContent = 'Map: ' + formatMapName(map);
  lobbyMapSelect.value = map;
});

// Visibility toggle (public/private) — admin only
visibilityBtn.addEventListener('click', () => {
  lobbyIsPublic = !lobbyIsPublic;
  socket.emit('toggleVisibility', { isPublic: lobbyIsPublic }, () => {});
  updateVisibilityBtn();
});

function updateVisibilityBtn() {
  if (lobbyIsPublic) {
    visibilityBtn.textContent = 'PUBLIC';
    visibilityBtn.classList.add('public');
  } else {
    visibilityBtn.textContent = 'PRIVATE';
    visibilityBtn.classList.remove('public');
  }
}

// Start game — admin only
startBtn.addEventListener('click', () => {
  socket.emit('startGame', (res) => {
    if (res && !res.success && res.error) alert(res.error);
  });
});

// Listen for game start broadcast from server
socket.on('gameStart', ({ map, code }) => {
  if (gameRunning) return;
  currentMap = map;
  currentCode = code;
  lobbyScreen.classList.remove('visible');
  startGame(map, code);
});

// ── SERVER LIST ───────────────────────────────────────────────────────────────
btnServers.addEventListener('click', () => {
  menuEl.style.display = 'none';
  serverListScreen.classList.add('visible');
  refreshServerList();
});

serverListBack.addEventListener('click', () => {
  serverListScreen.classList.remove('visible');
  menuEl.style.display = '';
});

serverListRefresh.addEventListener('click', refreshServerList);

function refreshServerList() {
  socket.emit('listLobbies', (res) => {
    serverListEl.innerHTML = '';
    const list = res.lobbies || [];
    serverListEmpty.style.display = list.length === 0 ? '' : 'none';
    list.forEach((lobby) => {
      const item = document.createElement('div');
      item.className = 'server-item';
      const statusText = lobby.started ? 'In Progress' : 'Waiting';
      item.innerHTML =
        '<div class="server-item-info">' +
        '<span class="server-item-map">' + formatMapName(lobby.map) + '</span>' +
        '<span class="server-item-status">' + statusText + '</span>' +
        '</div>' +
        '<span class="server-item-players">' + lobby.playerCount + ' / ' + lobby.maxPlayers + '</span>';
      item.addEventListener('click', () => joinLobbyByCode(lobby.code));
      serverListEl.appendChild(item);
    });
  });
}

function formatMapName(name) {
  return name.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
}

// ── SOCKET: multiplayer ───────────────────────────────────────────────────────
socket.on('playerJoined', (p) => {
  lobbyPlayers++;
  playerCountEl.textContent = 'Players: ' + lobbyPlayers + ' / 16';
  if (gameRunning) remotePlayerJoined(p);
});

socket.on('playerLeft', ({ id }) => {
  lobbyPlayers = Math.max(1, lobbyPlayers - 1);
  playerCountEl.textContent = 'Players: ' + lobbyPlayers + ' / 16';
  if (otherPlayerMeshes[id]) { scene.remove(otherPlayerMeshes[id]); delete otherPlayerMeshes[id]; }
});

socket.on('playerMoved', ({ id, x, y, z, yaw }) => {
  if (!gameRunning) return;
  let mesh = otherPlayerMeshes[id];
  if (!mesh) { mesh = createPlayerCube(); scene.add(mesh); otherPlayerMeshes[id] = mesh; }
  mesh.position.set(x, y, z);
  mesh.rotation.y = yaw;
});

function remotePlayerJoined(p) {
  if (!scene || otherPlayerMeshes[p.id]) return;
  const mesh = createPlayerCube();
  mesh.position.set(p.x, p.y, p.z);
  mesh.rotation.y = p.yaw || 0;
  scene.add(mesh);
  otherPlayerMeshes[p.id] = mesh;
}

function createPlayerCube() {
  const geo = new THREE.BoxGeometry(0.8, 1.8, 0.8);
  const mat = new THREE.MeshLambertMaterial({ color: 0xe63946 });
  return new THREE.Mesh(geo, mat);
}

// ── START GAME ────────────────────────────────────────────────────────────────
async function startGame(mapName, code) {
  loadingScreen.classList.add('visible');
  loadingText.textContent = 'Loading ' + formatMapName(mapName) + '...';
  loadingBar.style.width = '5%';

  // Performance: cap pixel ratio to reduce GPU load on high-DPI screens
  const MAX_PIXEL_RATIO = 1.5;
  const maxPixelRatio = Math.min(window.devicePixelRatio, MAX_PIXEL_RATIO);
  renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
  renderer.setPixelRatio(maxPixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFShadowMap;
  document.body.appendChild(renderer.domElement);

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);

  // Reduce fog distance on arabic map for performance
  const fogNear = mapName === 'arabic_city' ? 40 : 60;
  const fogFar  = mapName === 'arabic_city' ? 120 : 200;
  scene.fog = new THREE.Fog(0x87ceeb, fogNear, fogFar);

  const cameraFar = mapName === 'arabic_city' ? 150 : 300;
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, cameraFar);

  // Lighting
  scene.add(new THREE.AmbientLight(0xffffff, 0.8));
  const sun = new THREE.DirectionalLight(0xffffff, 1.0);
  sun.position.set(50, 100, 50);
  sun.castShadow = true;
  // Reduce shadow map size on arabic map for performance
  const shadowSize = mapName === 'arabic_city' ? 256 : 512;
  sun.shadow.mapSize.set(shadowSize, shadowSize);
  sun.shadow.camera.near = 0.5;
  sun.shadow.camera.far  = 200;
  sun.shadow.camera.left = sun.shadow.camera.bottom = -80;
  sun.shadow.camera.right = sun.shadow.camera.top   =  80;
  scene.add(sun);

  // Fallback ground — kept slightly below y=0 to avoid z-fighting with map floor
  const gGeo = new THREE.PlaneGeometry(400, 400);
  const gMat = new THREE.MeshLambertMaterial({ color: 0x3a7d44 });
  const ground = new THREE.Mesh(gGeo, gMat);
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = -0.05;
  ground.receiveShadow = true;
  scene.add(ground);
  collidables.push(ground);

  loadingBar.style.width = '15%';
  await loadMap(mapName);
  loadingBar.style.width = '100%';

  hudCode.textContent    = 'Code: ' + code;
  hudMap.textContent     = formatMapName(mapName);
  hudPlayers.textContent = lobbyPlayers + ' / 16';

  loadingScreen.classList.remove('visible');
  hud.classList.add('visible');
  crosshair.classList.add('visible');
  lockMsg.classList.add('visible');
  gameRunning = true;

  window.addEventListener('resize', onResize);
  renderer.domElement.addEventListener('click', () => {
    if (!chatOpen) renderer.domElement.requestPointerLock();
  });

  animate();
}

function loadMap(mapName) {
  const isArabMap = mapName === 'arabic_city';
  return new Promise((resolve) => {
    const loader = new GLTFLoader();
    loader.load(
      '/maps/' + mapName + '/scene.gltf',
      (gltf) => {
        const root = gltf.scene;

        // ── Step 1: add to scene so world matrices are computable ──────────────
        scene.add(root);
        root.updateMatrixWorld(true);

        // ── Step 2: compute initial bounding box in world space ────────────────
        const initBox = new THREE.Box3().setFromObject(root);
        const initSize = initBox.getSize(new THREE.Vector3());
        const maxDim = Math.max(initSize.x, initSize.y, initSize.z);
        console.log('[Map] raw size:', initSize.toArray().map(v => +v.toFixed(1)));

        // ── Step 3: auto-scale to ~150 world units on longest axis ─────────────
        const targetSize = 150;
        const scaleFactor = maxDim > 0 ? targetSize / maxDim : 1;
        root.scale.setScalar(scaleFactor);
        root.updateMatrixWorld(true);

        // ── Step 4: recompute box and centre map at origin ─────────────────────
        const box = new THREE.Box3().setFromObject(root);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        root.position.set(-center.x, -box.min.y, -center.z);
        root.updateMatrixWorld(true);

        console.log('[Map] final size:', size.toArray().map(v => +v.toFixed(2)),
                    'spawn y:', (size.y + player.height + 3).toFixed(2));

        // ── Step 5: convert PBR materials → Lambert (works in all WebGL modes)──
        let meshCount = 0;
        root.traverse((node) => {
          if (!node.isMesh) return;
          meshCount++;

          // Convert material(s) to MeshLambertMaterial for compatibility
          const mats = Array.isArray(node.material) ? node.material : [node.material];
          const converted = mats.map((mat) => {
            if (!mat) return new THREE.MeshLambertMaterial({ color: 0xcccccc });
            // Fix texture encoding for proper display
            if (mat.map) {
              mat.map.colorSpace = THREE.SRGBColorSpace;
              mat.map.needsUpdate = true;
            }
            const lamb = new THREE.MeshLambertMaterial({
              map:         mat.map         || null,
              color:       mat.color       ? mat.color.clone() : new THREE.Color(0xffffff),
              transparent: mat.transparent || false,
              opacity:     mat.opacity     !== undefined ? mat.opacity : 1,
              side:        THREE.DoubleSide,
            });
            return lamb;
          });
          node.material = converted.length === 1 ? converted[0] : converted;

          // Performance: disable shadows on arab map small meshes to reduce draw calls
          if (isArabMap) {
            node.castShadow    = false;
            node.receiveShadow = true;
          } else {
            node.castShadow    = true;
            node.receiveShadow = true;
          }
          node.frustumCulled = true;
          collidables.push(node);
        });

        console.log('[Map] mesh count:', meshCount, isArabMap ? '(shadows disabled for perf)' : '');

        // ── Step 6: find multiple spawn points across the map ──────────────────
        {
          // Concentric rings from center outward; 12 angles per ring for good coverage
          const SPAWN_SEARCH_RADII         = [0, 3, 6, 10, 15, 20, 25, 30, 40, 50, 60, 70];
          const SPAWN_SEARCH_ANGULAR_STEPS = 12;
          const GROUND_PLANE_Y             = 0.0;  // ignore fallback ground at y=-0.05
          const CEILING_CHECK_DIST         = 1.0;  // how far up to check for ceiling
          const MIN_CEILING_CLEARANCE      = 0.8;  // reject if ceiling is closer than this

          const spawnRay = new THREE.Raycaster();
          const downVec  = new THREE.Vector3(0, -1, 0);
          const upVec    = new THREE.Vector3(0, 1, 0);
          const testY    = size.y + 20;
          const spawnPoints = [];

          for (const r of SPAWN_SEARCH_RADII) {
            const angleCount = r === 0 ? 1 : SPAWN_SEARCH_ANGULAR_STEPS;
            for (let i = 0; i < angleCount; i++) {
              const a = (i / angleCount) * Math.PI * 2;
              const px = Math.cos(a) * r;
              const pz = Math.sin(a) * r;

              // Cast from very high above to find surfaces
              spawnRay.set(new THREE.Vector3(px, testY, pz), downVec);
              spawnRay.far = testY + 50;
              const hits = spawnRay.intersectObjects(collidables, true);

              // Find the first hit that is an actual map surface (not the fallback ground)
              for (const hit of hits) {
                if (hit.point.y <= GROUND_PLANE_Y) continue;

                // Verify this point is not inside geometry:
                // cast a ray upward from slightly above the surface — if it hits something
                // very close, the player would be trapped inside the mesh
                const checkOrigin = new THREE.Vector3(px, hit.point.y + player.height + 0.1, pz);
                spawnRay.set(checkOrigin, upVec);
                spawnRay.far = CEILING_CHECK_DIST;
                const ceilingHits = spawnRay.intersectObjects(collidables, true);
                if (ceilingHits.length > 0 && ceilingHits[0].distance < MIN_CEILING_CLEARANCE) {
                  continue; // too close to ceiling — player would be stuck
                }

                const spawnY = hit.point.y + player.height + 0.3;
                spawnPoints.push(new THREE.Vector3(px, spawnY, pz));
                break; // one valid point per column
              }
            }
          }

          // Pick a random spawn point; fallback to above-map if none found
          let chosenSpawn;
          if (spawnPoints.length > 0) {
            chosenSpawn = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
            console.log('[Map] ' + spawnPoints.length + ' spawn points found. Chosen y=' +
              chosenSpawn.y.toFixed(2) + ' at xz=(' + chosenSpawn.x.toFixed(0) + ',' + chosenSpawn.z.toFixed(0) + ')');
          } else {
            chosenSpawn = new THREE.Vector3(0, player.height + 3, 0);
            console.log('[Map] No surface found — fallback spawn y=' + chosenSpawn.y.toFixed(2));
          }

          player.pos.copy(chosenSpawn);
          player.vel.set(0, 0, 0);
        }

        resolve();
      },
      (xhr) => {
        if (xhr.total > 0) {
          loadingBar.style.width = (15 + (xhr.loaded / xhr.total) * 80) + '%';
        }
      },
      (err) => { console.error('[Map] load error', err); resolve(); }
    );
  });
}

// ── PHYSICS ───────────────────────────────────────────────────────────────────
const downRay = new THREE.Raycaster();
const wallRay = new THREE.Raycaster();
const downDir = new THREE.Vector3(0, -1, 0);
const wallDirs = [
  new THREE.Vector3( 1, 0,  0),
  new THREE.Vector3(-1, 0,  0),
  new THREE.Vector3( 0, 0,  1),
  new THREE.Vector3( 0, 0, -1),
];

function updatePhysics(dt) {
  if (!player.onGround) player.vel.y += GRAVITY * dt;

  // Horizontal movement
  const move = new THREE.Vector3();
  if (keys['KeyW']) move.z -= 1;
  if (keys['KeyS']) move.z += 1;
  if (keys['KeyA']) move.x -= 1;
  if (keys['KeyD']) move.x += 1;
  if (move.lengthSq() > 0) {
    move.normalize().applyEuler(new THREE.Euler(0, player.yaw, 0));
    player.vel.x = move.x * player.speed;
    player.vel.z = move.z * player.speed;
  } else {
    player.vel.x *= 0.82;
    player.vel.z *= 0.82;
  }

  const next = player.pos.clone().addScaledVector(player.vel, dt);

  // Ground collision
  downRay.set(new THREE.Vector3(next.x, player.pos.y + 0.3, next.z), downDir);
  downRay.far = player.height + 0.5;
  const groundHits = downRay.intersectObjects(collidables, true);
  if (groundHits.length > 0 && groundHits[0].distance <= player.height + 0.2) {
    next.y = groundHits[0].point.y + player.height;
    player.vel.y = 0;
    player.onGround = true;
  } else {
    player.onGround = false;
  }

  // Wall collision
  const wallOrigin = new THREE.Vector3(next.x, next.y - player.height * 0.5, next.z);
  for (const dir of wallDirs) {
    wallRay.set(wallOrigin, dir);
    wallRay.far = player.radius + 0.05;
    const hits = wallRay.intersectObjects(collidables, true);
    if (hits.length > 0) {
      const overlap = (player.radius + 0.05) - hits[0].distance;
      next.x -= dir.x * overlap;
      next.z -= dir.z * overlap;
    }
  }

  // Floor safety net
  if (next.y < player.height) { next.y = player.height; player.vel.y = 0; player.onGround = true; }

  player.pos.copy(next);
}

// ── RENDER LOOP ───────────────────────────────────────────────────────────────
let prevTime = 0;
let lastSend = 0;

function animate(ts = 0) {
  requestAnimationFrame(animate);
  if (!gameRunning) return;

  const dt = Math.min((ts - prevTime) / 1000, 0.05);
  prevTime = ts;

  updatePhysics(dt);

  camera.position.copy(player.pos);
  camera.rotation.order = 'YXZ';
  camera.rotation.y = player.yaw;
  camera.rotation.x = player.pitch;

  // Network update ~20 Hz
  if (ts - lastSend > 50) {
    socket.emit('playerMove', { x: player.pos.x, y: player.pos.y, z: player.pos.z, yaw: player.yaw });
    lastSend = ts;
    hudPlayers.textContent = (1 + Object.keys(otherPlayerMeshes).length) + ' / 16';
  }

  renderer.render(scene, camera);
}

function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
</script>
</body>
</html>
