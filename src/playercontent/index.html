<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BaiterFPS</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0a0f; color: #fff; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
    canvas { display: block; }

    #menu {
      position: fixed; inset: 0;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      background: radial-gradient(ellipse at center, #0d1b2a 0%, #050508 100%);
      z-index: 10;
    }
    #menu h1 {
      font-size: 4rem; font-weight: 900; letter-spacing: 0.1em;
      color: #e63946; text-shadow: 0 0 30px #e63946aa;
      margin-bottom: 3rem;
    }
    .menu-btn {
      width: 280px; padding: 1rem 2rem;
      margin: 0.6rem 0;
      background: transparent;
      border: 2px solid #e63946;
      color: #fff; font-size: 1.2rem;
      cursor: pointer; letter-spacing: 0.05em;
      transition: background 0.2s, box-shadow 0.2s;
    }
    .menu-btn:hover {
      background: #e63946;
      box-shadow: 0 0 20px #e63946;
    }

    #code-dialog {
      position: fixed; inset: 0;
      display: none; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.85); z-index: 20;
    }
    #code-dialog.visible { display: flex; }
    .dialog-box {
      background: #0d1b2a; border: 2px solid #e63946;
      padding: 2.5rem 3rem; display: flex; flex-direction: column; gap: 1rem;
      min-width: 320px;
    }
    .dialog-box h2 { color: #e63946; font-size: 1.5rem; }
    .dialog-box input {
      background: #111; border: 1px solid #444; color: #fff;
      padding: 0.7rem 1rem; font-size: 1.3rem; letter-spacing: 0.15em;
      text-transform: uppercase; outline: none;
    }
    .dialog-box input:focus { border-color: #e63946; }
    .dialog-row { display: flex; gap: 0.5rem; }
    .dialog-row button {
      flex: 1; padding: 0.7rem;
      background: transparent; border: 1.5px solid #e63946;
      color: #fff; cursor: pointer; font-size: 1rem;
      transition: background 0.15s;
    }
    .dialog-row button:hover { background: #e63946; }
    #dialog-error { color: #ff6b6b; font-size: 0.9rem; min-height: 1.2rem; }

    #lobby-screen {
      position: fixed; inset: 0;
      display: none; flex-direction: column;
      align-items: center; justify-content: center;
      background: radial-gradient(ellipse at center, #0d1b2a 0%, #050508 100%);
      z-index: 10;
    }
    #lobby-screen.visible { display: flex; }
    #lobby-screen h2 { font-size: 2rem; color: #e63946; margin-bottom: 1rem; }
    #lobby-code-display {
      font-size: 3rem; font-weight: 900; letter-spacing: 0.3em;
      color: #fff; background: #111; padding: 0.8rem 2rem;
      border: 2px solid #e63946; margin-bottom: 0.5rem;
    }
    #lobby-map-display { color: #aaa; font-size: 1.1rem; margin-bottom: 1rem; }
    #player-count { color: #aaa; font-size: 1rem; margin-bottom: 1rem; }
    #visibility-toggle {
      width: 220px; padding: 0.7rem;
      margin-bottom: 1.5rem;
      background: transparent; border: 1.5px solid #e63946;
      color: #fff; font-size: 1rem; cursor: pointer;
      transition: background 0.15s;
    }
    #visibility-toggle:hover { background: #e6394644; }
    #visibility-toggle.public { border-color: #4caf50; color: #4caf50; }
    #start-btn {
      width: 220px; padding: 1rem;
      background: #e63946; border: none;
      color: #fff; font-size: 1.2rem; cursor: pointer;
      transition: box-shadow 0.2s;
    }
    #start-btn:hover { box-shadow: 0 0 20px #e63946; }

    #server-list-screen {
      position: fixed; inset: 0;
      display: none; flex-direction: column;
      align-items: center; justify-content: flex-start;
      padding-top: 4rem;
      background: radial-gradient(ellipse at center, #0d1b2a 0%, #050508 100%);
      z-index: 10; overflow-y: auto;
    }
    #server-list-screen.visible { display: flex; }
    #server-list-screen h2 { font-size: 2rem; color: #e63946; margin-bottom: 1.5rem; }
    #server-list {
      width: 90%; max-width: 600px;
      display: flex; flex-direction: column; gap: 0.5rem;
      margin-bottom: 2rem;
    }
    .server-item {
      display: flex; justify-content: space-between; align-items: center;
      background: #111; border: 1px solid #333; padding: 1rem 1.5rem;
      cursor: pointer; transition: border-color 0.15s, background 0.15s;
    }
    .server-item:hover { border-color: #e63946; background: #1a1a2e; }
    .server-item-map { color: #fff; font-size: 1.1rem; }
    .server-item-players { color: #aaa; font-size: 0.95rem; }
    #server-list-empty { color: #666; font-size: 1rem; margin-bottom: 2rem; }
    #server-list-back {
      width: 200px; padding: 0.8rem;
      background: transparent; border: 1.5px solid #e63946;
      color: #fff; font-size: 1rem; cursor: pointer;
      transition: background 0.15s; margin-bottom: 2rem;
    }
    #server-list-back:hover { background: #e63946; }
    #server-list-refresh {
      width: 200px; padding: 0.8rem;
      background: transparent; border: 1.5px solid #4caf50;
      color: #4caf50; font-size: 1rem; cursor: pointer;
      transition: background 0.15s; margin-bottom: 1rem;
    }
    #server-list-refresh:hover { background: #4caf5044; }

    #loading-screen {
      position: fixed; inset: 0;
      display: none; flex-direction: column;
      align-items: center; justify-content: center;
      background: #050508; z-index: 30;
    }
    #loading-screen.visible { display: flex; }
    #loading-screen p { font-size: 1.4rem; color: #e63946; margin-bottom: 1rem; }
    #loading-bar-wrap {
      width: 320px; height: 6px;
      background: #222; border-radius: 3px; overflow: hidden;
    }
    #loading-bar {
      height: 100%; width: 0%;
      background: #e63946; transition: width 0.2s;
    }

    #hud {
      position: fixed; top: 0; left: 0; right: 0;
      display: none; align-items: center; justify-content: space-between;
      padding: 0.8rem 1.5rem;
      background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent);
      z-index: 5; pointer-events: none;
    }
    #hud.visible { display: flex; }
    #hud-code { color: #e63946; font-weight: bold; letter-spacing: 0.1em; }
    #hud-map { color: #aaa; }
    #hud-players { color: #fff; }

    #crosshair {
      position: fixed; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      display: none; pointer-events: none; z-index: 5;
      width: 0; height: 0;
    }
    #crosshair.visible { display: block; }
    #crosshair::before, #crosshair::after {
      content: ''; position: absolute;
      background: rgba(255,255,255,0.85);
    }
    #crosshair::before { width: 2px; height: 16px; top: -8px; left: -1px; }
    #crosshair::after  { width: 16px; height: 2px; top: -1px; left: -8px; }

    #lock-msg {
      position: fixed; bottom: 3rem; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.7); padding: 0.6rem 1.4rem;
      color: #aaa; font-size: 0.95rem;
      display: none; z-index: 5;
    }
    #lock-msg.visible { display: block; }
  </style>
</head>
<body>

<!-- Main Menu -->
<div id="menu">
  <h1>BAITERFPS</h1>
  <button class="menu-btn" id="btn-create">CREATE LOBBY</button>
  <button class="menu-btn" id="btn-enter">ENTER CODE</button>
  <button class="menu-btn" id="btn-servers">SERVER LIST</button>
</div>

<!-- Enter Code Dialog -->
<div id="code-dialog">
  <div class="dialog-box">
    <h2>ENTER LOBBY CODE</h2>
    <input id="code-input" type="text" maxlength="6" placeholder="XXXXXX" autocomplete="off" />
    <div id="dialog-error"></div>
    <div class="dialog-row">
      <button id="code-join-btn">JOIN</button>
      <button id="code-cancel-btn">CANCEL</button>
    </div>
  </div>
</div>

<!-- Server List Screen -->
<div id="server-list-screen">
  <h2>PUBLIC SERVERS</h2>
  <button id="server-list-refresh">REFRESH</button>
  <div id="server-list"></div>
  <div id="server-list-empty">No public servers available.</div>
  <button id="server-list-back">BACK</button>
</div>

<!-- Lobby Waiting Screen -->
<div id="lobby-screen">
  <h2>LOBBY</h2>
  <div id="lobby-code-display">------</div>
  <div id="lobby-map-display">Map: -</div>
  <div id="player-count">Players: 1 / 16</div>
  <button id="visibility-toggle">PRIVATE</button>
  <button id="start-btn">START GAME</button>
</div>

<!-- Loading Screen -->
<div id="loading-screen">
  <p id="loading-text">Loading map...</p>
  <div id="loading-bar-wrap"><div id="loading-bar"></div></div>
</div>

<!-- HUD -->
<div id="hud">
  <div id="hud-code"></div>
  <div id="hud-map"></div>
  <div id="hud-players"></div>
</div>
<div id="crosshair"></div>
<div id="lock-msg">Click to capture mouse</div>

<!-- Three.js + Socket.io -->
<script src="/socket.io/socket.io.js"></script>
<script type="importmap">
{
  "imports": {
    "three": "/vendor/three/build/three.module.js",
    "three/addons/": "/vendor/three/examples/jsm/"
  }
}
</script>
<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

// Service Worker for asset caching
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js').catch(() => {});
}

// DOM refs
const menuEl        = document.getElementById('menu');
const btnCreate     = document.getElementById('btn-create');
const btnEnter      = document.getElementById('btn-enter');
const btnServers    = document.getElementById('btn-servers');
const codeDialog    = document.getElementById('code-dialog');
const codeInput     = document.getElementById('code-input');
const codeJoinBtn   = document.getElementById('code-join-btn');
const codeCancelBtn = document.getElementById('code-cancel-btn');
const dialogError   = document.getElementById('dialog-error');
const lobbyScreen   = document.getElementById('lobby-screen');
const lobbyCodeEl   = document.getElementById('lobby-code-display');
const lobbyMapEl    = document.getElementById('lobby-map-display');
const playerCountEl = document.getElementById('player-count');
const visibilityBtn = document.getElementById('visibility-toggle');
const startBtn      = document.getElementById('start-btn');
const serverListScreen = document.getElementById('server-list-screen');
const serverListEl     = document.getElementById('server-list');
const serverListEmpty  = document.getElementById('server-list-empty');
const serverListBack   = document.getElementById('server-list-back');
const serverListRefresh= document.getElementById('server-list-refresh');
const loadingScreen = document.getElementById('loading-screen');
const loadingText   = document.getElementById('loading-text');
const loadingBar    = document.getElementById('loading-bar');
const hud           = document.getElementById('hud');
const hudCode       = document.getElementById('hud-code');
const hudMap        = document.getElementById('hud-map');
const hudPlayers    = document.getElementById('hud-players');
const crosshair     = document.getElementById('crosshair');
const lockMsg       = document.getElementById('lock-msg');

// Socket — prefer websocket for speed
const socket = io({ transports: ['websocket', 'polling'] });

// State
let currentMap  = null;
let currentCode = null;
let gameRunning = false;
let lobbyPlayers = 1;
let lobbyIsPublic = false;

// Three.js globals
let renderer, scene, camera;
let collidables = [];
let otherPlayerMeshes = {};

// Player state
const player = {
  pos: new THREE.Vector3(0, 5, 0),
  vel: new THREE.Vector3(),
  yaw: 0,
  pitch: 0,
  onGround: false,
  height: 1.8,
  radius: 0.4,
  speed: 8,
  jumpSpeed: 7,
};
const GRAVITY = -18;
const keys = {};

// Pointer lock
let isLocked = false;
document.addEventListener('pointerlockchange', () => {
  isLocked = !!renderer && document.pointerLockElement === renderer.domElement;
  if (gameRunning) lockMsg.classList.toggle('visible', !isLocked);
});
document.addEventListener('mousemove', (e) => {
  if (!isLocked) return;
  const sens = 0.0015;
  player.yaw   -= e.movementX * sens;
  player.pitch -= e.movementY * sens;
  player.pitch = Math.max(-Math.PI / 2.2, Math.min(Math.PI / 2.2, player.pitch));
});

// Keyboard
document.addEventListener('keydown', (e) => {
  keys[e.code] = true;
  if (e.code === 'Space' && player.onGround) {
    player.vel.y = player.jumpSpeed;
    player.onGround = false;
  }
});
document.addEventListener('keyup', (e) => { keys[e.code] = false; });

// ── MENU ──────────────────────────────────────────────────────────────────────
btnCreate.addEventListener('click', () => {
  socket.emit('createLobby', { isPublic: false }, (res) => {
    if (!res.success) { alert('Could not create lobby.'); return; }
    currentCode  = res.code;
    currentMap   = res.map;
    lobbyPlayers = 1;
    lobbyIsPublic = false;
    lobbyCodeEl.textContent = res.code;
    lobbyMapEl.textContent  = 'Map: ' + formatMapName(res.map);
    playerCountEl.textContent = 'Players: 1 / 16';
    updateVisibilityBtn();
    menuEl.style.display = 'none';
    lobbyScreen.classList.add('visible');
  });
});

btnEnter.addEventListener('click', () => {
  codeInput.value = '';
  dialogError.textContent = '';
  codeDialog.classList.add('visible');
  setTimeout(() => codeInput.focus(), 50);
});

codeCancelBtn.addEventListener('click', () => codeDialog.classList.remove('visible'));
codeInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') codeJoinBtn.click(); });

codeJoinBtn.addEventListener('click', () => {
  const code = codeInput.value.trim().toUpperCase();
  if (code.length !== 6) { dialogError.textContent = 'Code must be 6 characters.'; return; }
  dialogError.textContent = '';
  joinLobbyByCode(code);
});

function joinLobbyByCode(code) {
  socket.emit('joinLobby', { code }, (res) => {
    if (!res.success) { dialogError.textContent = res.error || 'Failed to join.'; return; }
    currentCode  = code;
    currentMap   = res.map;
    lobbyPlayers = 1 + (res.existingPlayers ? res.existingPlayers.length : 0);
    lobbyCodeEl.textContent = code;
    lobbyMapEl.textContent  = 'Map: ' + formatMapName(res.map);
    playerCountEl.textContent = 'Players: ' + lobbyPlayers + ' / 16';
    if (res.existingPlayers) res.existingPlayers.forEach(remotePlayerJoined);
    codeDialog.classList.remove('visible');
    serverListScreen.classList.remove('visible');
    menuEl.style.display = 'none';
    lobbyScreen.classList.add('visible');
  });
}

// Visibility toggle (public/private)
visibilityBtn.addEventListener('click', () => {
  lobbyIsPublic = !lobbyIsPublic;
  socket.emit('toggleVisibility', { isPublic: lobbyIsPublic }, () => {});
  updateVisibilityBtn();
});

function updateVisibilityBtn() {
  if (lobbyIsPublic) {
    visibilityBtn.textContent = 'PUBLIC';
    visibilityBtn.classList.add('public');
  } else {
    visibilityBtn.textContent = 'PRIVATE';
    visibilityBtn.classList.remove('public');
  }
}

// Start game — broadcast to all lobby members via server
startBtn.addEventListener('click', () => {
  socket.emit('startGame', () => {});
});

// Listen for game start broadcast from server (triggered by any player clicking start)
socket.on('gameStart', ({ map, code }) => {
  if (gameRunning) return;
  currentMap = map;
  currentCode = code;
  lobbyScreen.classList.remove('visible');
  startGame(map, code);
});

// ── SERVER LIST ───────────────────────────────────────────────────────────────
btnServers.addEventListener('click', () => {
  menuEl.style.display = 'none';
  serverListScreen.classList.add('visible');
  refreshServerList();
});

serverListBack.addEventListener('click', () => {
  serverListScreen.classList.remove('visible');
  menuEl.style.display = '';
});

serverListRefresh.addEventListener('click', refreshServerList);

function refreshServerList() {
  socket.emit('listLobbies', (res) => {
    serverListEl.innerHTML = '';
    const list = res.lobbies || [];
    serverListEmpty.style.display = list.length === 0 ? '' : 'none';
    list.forEach((lobby) => {
      const item = document.createElement('div');
      item.className = 'server-item';
      item.innerHTML =
        '<span class="server-item-map">' + formatMapName(lobby.map) + '</span>' +
        '<span class="server-item-players">' + lobby.playerCount + ' / ' + lobby.maxPlayers + '</span>';
      item.addEventListener('click', () => joinLobbyByCode(lobby.code));
      serverListEl.appendChild(item);
    });
  });
}

function formatMapName(name) {
  return name.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
}

// ── SOCKET: multiplayer ───────────────────────────────────────────────────────
socket.on('playerJoined', (p) => {
  lobbyPlayers++;
  playerCountEl.textContent = 'Players: ' + lobbyPlayers + ' / 16';
  if (gameRunning) remotePlayerJoined(p);
});

socket.on('playerLeft', ({ id }) => {
  lobbyPlayers = Math.max(1, lobbyPlayers - 1);
  playerCountEl.textContent = 'Players: ' + lobbyPlayers + ' / 16';
  if (otherPlayerMeshes[id]) { scene.remove(otherPlayerMeshes[id]); delete otherPlayerMeshes[id]; }
});

socket.on('playerMoved', ({ id, x, y, z, yaw }) => {
  if (!gameRunning) return;
  let mesh = otherPlayerMeshes[id];
  if (!mesh) { mesh = createPlayerCube(); scene.add(mesh); otherPlayerMeshes[id] = mesh; }
  mesh.position.set(x, y, z);
  mesh.rotation.y = yaw;
});

function remotePlayerJoined(p) {
  if (!scene || otherPlayerMeshes[p.id]) return;
  const mesh = createPlayerCube();
  mesh.position.set(p.x, p.y, p.z);
  mesh.rotation.y = p.yaw || 0;
  scene.add(mesh);
  otherPlayerMeshes[p.id] = mesh;
}

function createPlayerCube() {
  const geo = new THREE.BoxGeometry(0.8, 1.8, 0.8);
  const mat = new THREE.MeshLambertMaterial({ color: 0xe63946 });
  return new THREE.Mesh(geo, mat);
}

// ── START GAME ────────────────────────────────────────────────────────────────
async function startGame(mapName, code) {
  loadingScreen.classList.add('visible');
  loadingText.textContent = 'Loading ' + formatMapName(mapName) + '...';
  loadingBar.style.width = '5%';

  // Performance: cap pixel ratio to reduce GPU load on high-DPI screens
  const MAX_PIXEL_RATIO = 1.5;
  const maxPixelRatio = Math.min(window.devicePixelRatio, MAX_PIXEL_RATIO);
  renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
  renderer.setPixelRatio(maxPixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFShadowMap;
  document.body.appendChild(renderer.domElement);

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);
  scene.fog = new THREE.Fog(0x87ceeb, 60, 200);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 300);

  // Lighting
  scene.add(new THREE.AmbientLight(0xffffff, 0.8));
  const sun = new THREE.DirectionalLight(0xffffff, 1.0);
  sun.position.set(50, 100, 50);
  sun.castShadow = true;
  sun.shadow.mapSize.set(512, 512);
  sun.shadow.camera.near = 0.5;
  sun.shadow.camera.far  = 200;
  sun.shadow.camera.left = sun.shadow.camera.bottom = -80;
  sun.shadow.camera.right = sun.shadow.camera.top   =  80;
  scene.add(sun);

  // Fallback ground — kept slightly below y=0 to avoid z-fighting with map floor
  const gGeo = new THREE.PlaneGeometry(400, 400);
  const gMat = new THREE.MeshLambertMaterial({ color: 0x3a7d44 });
  const ground = new THREE.Mesh(gGeo, gMat);
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = -0.05;
  ground.receiveShadow = true;
  scene.add(ground);
  collidables.push(ground);

  loadingBar.style.width = '15%';
  await loadMap(mapName);
  loadingBar.style.width = '100%';

  hudCode.textContent    = 'Code: ' + code;
  hudMap.textContent     = formatMapName(mapName);
  hudPlayers.textContent = lobbyPlayers + ' / 16';

  loadingScreen.classList.remove('visible');
  hud.classList.add('visible');
  crosshair.classList.add('visible');
  lockMsg.classList.add('visible');
  gameRunning = true;

  window.addEventListener('resize', onResize);
  renderer.domElement.addEventListener('click', () => renderer.domElement.requestPointerLock());

  animate();
}

function loadMap(mapName) {
  return new Promise((resolve) => {
    const loader = new GLTFLoader();
    loader.load(
      '/maps/' + mapName + '/scene.gltf',
      (gltf) => {
        const root = gltf.scene;

        // ── Step 1: add to scene so world matrices are computable ──────────────
        scene.add(root);
        root.updateMatrixWorld(true);

        // ── Step 2: compute initial bounding box in world space ────────────────
        const initBox = new THREE.Box3().setFromObject(root);
        const initSize = initBox.getSize(new THREE.Vector3());
        const maxDim = Math.max(initSize.x, initSize.y, initSize.z);
        console.log('[Map] raw size:', initSize.toArray().map(v => +v.toFixed(1)));

        // ── Step 3: auto-scale to ~150 world units on longest axis ─────────────
        const targetSize = 150;
        const scaleFactor = maxDim > 0 ? targetSize / maxDim : 1;
        root.scale.setScalar(scaleFactor);
        root.updateMatrixWorld(true);

        // ── Step 4: recompute box and centre map at origin ─────────────────────
        const box = new THREE.Box3().setFromObject(root);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        root.position.set(-center.x, -box.min.y, -center.z);
        root.updateMatrixWorld(true);

        console.log('[Map] final size:', size.toArray().map(v => +v.toFixed(2)),
                    'spawn y:', (size.y + player.height + 3).toFixed(2));

        // ── Step 5: convert PBR materials → Lambert (works in all WebGL modes)──
        root.traverse((node) => {
          if (!node.isMesh) return;

          // Convert material(s) to MeshLambertMaterial for compatibility
          const mats = Array.isArray(node.material) ? node.material : [node.material];
          const converted = mats.map((mat) => {
            if (!mat) return new THREE.MeshLambertMaterial({ color: 0xcccccc });
            // Fix texture encoding for proper display
            if (mat.map) {
              mat.map.colorSpace = THREE.SRGBColorSpace;
              mat.map.needsUpdate = true;
            }
            const lamb = new THREE.MeshLambertMaterial({
              map:         mat.map         || null,
              color:       mat.color       ? mat.color.clone() : new THREE.Color(0xffffff),
              transparent: mat.transparent || false,
              opacity:     mat.opacity     !== undefined ? mat.opacity : 1,
              side:        THREE.DoubleSide,
            });
            return lamb;
          });
          node.material = converted.length === 1 ? converted[0] : converted;

          node.castShadow    = true;
          node.receiveShadow = true;
          node.frustumCulled = true;
          collidables.push(node);
        });

        // ── Step 6: find multiple spawn points across the map ──────────────────
        {
          // Concentric rings from center outward; 12 angles per ring for good coverage
          const SPAWN_SEARCH_RADII         = [0, 3, 6, 10, 15, 20, 25, 30, 40, 50, 60, 70];
          const SPAWN_SEARCH_ANGULAR_STEPS = 12;
          const GROUND_PLANE_Y             = 0.0;  // ignore fallback ground at y=-0.05
          const CEILING_CHECK_DIST         = 1.0;  // how far up to check for ceiling
          const MIN_CEILING_CLEARANCE      = 0.8;  // reject if ceiling is closer than this

          const spawnRay = new THREE.Raycaster();
          const downVec  = new THREE.Vector3(0, -1, 0);
          const upVec    = new THREE.Vector3(0, 1, 0);
          const testY    = size.y + 20;
          const spawnPoints = [];

          for (const r of SPAWN_SEARCH_RADII) {
            const angleCount = r === 0 ? 1 : SPAWN_SEARCH_ANGULAR_STEPS;
            for (let i = 0; i < angleCount; i++) {
              const a = (i / angleCount) * Math.PI * 2;
              const px = Math.cos(a) * r;
              const pz = Math.sin(a) * r;

              // Cast from very high above to find surfaces
              spawnRay.set(new THREE.Vector3(px, testY, pz), downVec);
              spawnRay.far = testY + 50;
              const hits = spawnRay.intersectObjects(collidables, true);

              // Find the first hit that is an actual map surface (not the fallback ground)
              for (const hit of hits) {
                if (hit.point.y <= GROUND_PLANE_Y) continue;

                // Verify this point is not inside geometry:
                // cast a ray upward from slightly above the surface — if it hits something
                // very close, the player would be trapped inside the mesh
                const checkOrigin = new THREE.Vector3(px, hit.point.y + player.height + 0.1, pz);
                spawnRay.set(checkOrigin, upVec);
                spawnRay.far = CEILING_CHECK_DIST;
                const ceilingHits = spawnRay.intersectObjects(collidables, true);
                if (ceilingHits.length > 0 && ceilingHits[0].distance < MIN_CEILING_CLEARANCE) {
                  continue; // too close to ceiling — player would be stuck
                }

                const spawnY = hit.point.y + player.height + 0.3;
                spawnPoints.push(new THREE.Vector3(px, spawnY, pz));
                break; // one valid point per column
              }
            }
          }

          // Pick a random spawn point; fallback to above-map if none found
          let chosenSpawn;
          if (spawnPoints.length > 0) {
            chosenSpawn = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
            console.log('[Map] ' + spawnPoints.length + ' spawn points found. Chosen y=' +
              chosenSpawn.y.toFixed(2) + ' at xz=(' + chosenSpawn.x.toFixed(0) + ',' + chosenSpawn.z.toFixed(0) + ')');
          } else {
            chosenSpawn = new THREE.Vector3(0, player.height + 3, 0);
            console.log('[Map] No surface found — fallback spawn y=' + chosenSpawn.y.toFixed(2));
          }

          player.pos.copy(chosenSpawn);
          player.vel.set(0, 0, 0);
        }

        resolve();
      },
      (xhr) => {
        if (xhr.total > 0) {
          loadingBar.style.width = (15 + (xhr.loaded / xhr.total) * 80) + '%';
        }
      },
      (err) => { console.error('[Map] load error', err); resolve(); }
    );
  });
}

// ── PHYSICS ───────────────────────────────────────────────────────────────────
const downRay = new THREE.Raycaster();
const wallRay = new THREE.Raycaster();
const downDir = new THREE.Vector3(0, -1, 0);
const wallDirs = [
  new THREE.Vector3( 1, 0,  0),
  new THREE.Vector3(-1, 0,  0),
  new THREE.Vector3( 0, 0,  1),
  new THREE.Vector3( 0, 0, -1),
];

function updatePhysics(dt) {
  if (!player.onGround) player.vel.y += GRAVITY * dt;

  // Horizontal movement
  const move = new THREE.Vector3();
  if (keys['KeyW']) move.z -= 1;
  if (keys['KeyS']) move.z += 1;
  if (keys['KeyA']) move.x -= 1;
  if (keys['KeyD']) move.x += 1;
  if (move.lengthSq() > 0) {
    move.normalize().applyEuler(new THREE.Euler(0, player.yaw, 0));
    player.vel.x = move.x * player.speed;
    player.vel.z = move.z * player.speed;
  } else {
    player.vel.x *= 0.82;
    player.vel.z *= 0.82;
  }

  const next = player.pos.clone().addScaledVector(player.vel, dt);

  // Ground collision
  downRay.set(new THREE.Vector3(next.x, player.pos.y + 0.3, next.z), downDir);
  downRay.far = player.height + 0.5;
  const groundHits = downRay.intersectObjects(collidables, true);
  if (groundHits.length > 0 && groundHits[0].distance <= player.height + 0.2) {
    next.y = groundHits[0].point.y + player.height;
    player.vel.y = 0;
    player.onGround = true;
  } else {
    player.onGround = false;
  }

  // Wall collision
  const wallOrigin = new THREE.Vector3(next.x, next.y - player.height * 0.5, next.z);
  for (const dir of wallDirs) {
    wallRay.set(wallOrigin, dir);
    wallRay.far = player.radius + 0.05;
    const hits = wallRay.intersectObjects(collidables, true);
    if (hits.length > 0) {
      const overlap = (player.radius + 0.05) - hits[0].distance;
      next.x -= dir.x * overlap;
      next.z -= dir.z * overlap;
    }
  }

  // Floor safety net
  if (next.y < player.height) { next.y = player.height; player.vel.y = 0; player.onGround = true; }

  player.pos.copy(next);
}

// ── RENDER LOOP ───────────────────────────────────────────────────────────────
let prevTime = 0;
let lastSend = 0;

function animate(ts = 0) {
  requestAnimationFrame(animate);
  if (!gameRunning) return;

  const dt = Math.min((ts - prevTime) / 1000, 0.05);
  prevTime = ts;

  updatePhysics(dt);

  camera.position.copy(player.pos);
  camera.rotation.order = 'YXZ';
  camera.rotation.y = player.yaw;
  camera.rotation.x = player.pitch;

  // Network update ~20 Hz
  if (ts - lastSend > 50) {
    socket.emit('playerMove', { x: player.pos.x, y: player.pos.y, z: player.pos.z, yaw: player.yaw });
    lastSend = ts;
    hudPlayers.textContent = (1 + Object.keys(otherPlayerMeshes).length) + ' / 16';
  }

  renderer.render(scene, camera);
}

function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
</script>
</body>
</html>
